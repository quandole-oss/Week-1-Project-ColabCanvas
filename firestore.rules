rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Check if user is a member of the room
    function isRoomMember(roomId) {
      return isAuthenticated() &&
        request.auth.uid in get(/databases/$(database)/documents/rooms/$(roomId)).data.members;
    }

    // Rooms collection
    match /rooms/{roomId} {
      // Anyone authenticated can create rooms (they become the first member)
      allow create: if isAuthenticated() &&
        request.auth.uid in request.resource.data.members &&
        request.resource.data.createdBy == request.auth.uid;

      // Anyone authenticated can read rooms (needed for join flow — room data
      // only contains UIDs and display names, not sensitive information)
      allow read: if isAuthenticated();

      // Room updates: three branches to prevent member removal & room takeover
      allow update: if isAuthenticated() &&
        request.resource.data.createdBy == resource.data.createdBy && (
          // Branch 1: Existing members updating non-member fields
          (request.auth.uid in resource.data.members &&
           !request.resource.data.diff(resource.data).affectedKeys().hasAny(['members'])) ||
          // Branch 2: Existing members modifying the members list — must keep all current members (no removal)
          (request.auth.uid in resource.data.members &&
           request.resource.data.members.hasAll(resource.data.members)) ||
          // Branch 3: Non-members joining — must keep all existing members AND add exactly one
          (!(request.auth.uid in resource.data.members) &&
           request.auth.uid in request.resource.data.members &&
           request.resource.data.members.hasAll(resource.data.members) &&
           request.resource.data.members.size() == resource.data.members.size() + 1 &&
           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['members']))
        );

      // Only room creator can delete
      allow delete: if isAuthenticated() &&
        resource.data.createdBy == request.auth.uid;

      // AI requests subcollection within rooms
      match /aiRequests/{requestId} {
        // Only room members can create AI requests with validated fields
        allow create: if isRoomMember(roomId) &&
          request.resource.data.userId == request.auth.uid &&
          request.resource.data.keys().hasAll(['command', 'userId', 'status']) &&
          request.resource.data.keys().hasOnly(['command', 'userId', 'status', 'canvasObjects', 'viewportCenter', 'createdAt']) &&
          request.resource.data.status == 'pending' &&
          request.resource.data.command is string &&
          request.resource.data.command.size() > 0 &&
          request.resource.data.command.size() <= 500;

        // Room members can read results
        allow read: if isRoomMember(roomId);

        // No client updates/deletes (only the Cloud Function writes results)
        allow update, delete: if false;
      }

      // Objects subcollection within rooms
      match /objects/{objectId} {
        // Room members can read objects
        allow read: if isRoomMember(roomId);

        // Room members can create objects with validated schema
        allow create: if isRoomMember(roomId) &&
          request.resource.data.keys().hasAll(['id', 'type', 'props', 'zIndex']) &&
          request.resource.data.type in ['rect', 'circle', 'line', 'triangle', 'star', 'hexagon', 'sticky', 'textbox'];

        // Any room member can update objects (collaborative editing)
        allow update: if isRoomMember(roomId) &&
          (!('type' in request.resource.data) ||
           request.resource.data.type in ['rect', 'circle', 'line', 'triangle', 'star', 'hexagon', 'sticky', 'textbox']);

        // Any room member can delete objects (collaborative editing)
        allow delete: if isRoomMember(roomId);
      }
    }
  }
}
